# -*- coding: utf-8 -*-

"""
akoya

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from akoya.api_helper import APIHelper


class Items(object):

    """Implementation of the 'Items' model.

    Attributes:
        cost_basis (float): Total amount of money spent acquiring this lot
            including any fees or commission expenses incurred.
        current_value (float): Lot market value
        original_purchase_date (datetime): Lot acquired date.
        position_type (PositionType): LONG, SHORT.
        purchased_price (float): Original purchase price.
        quantity (float): Lot quantity.
        additional_properties (Dict[str, Any]): The additional properties for
            the model.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "cost_basis": 'costBasis',
        "current_value": 'currentValue',
        "original_purchase_date": 'originalPurchaseDate',
        "position_type": 'positionType',
        "purchased_price": 'purchasedPrice',
        "quantity": 'quantity'
    }

    _optionals = [
        'cost_basis',
        'current_value',
        'original_purchase_date',
        'position_type',
        'purchased_price',
        'quantity',
    ]

    def __init__(self,
                 cost_basis=APIHelper.SKIP,
                 current_value=APIHelper.SKIP,
                 original_purchase_date=APIHelper.SKIP,
                 position_type=APIHelper.SKIP,
                 purchased_price=APIHelper.SKIP,
                 quantity=APIHelper.SKIP,
                 additional_properties=None):
        """Constructor for the Items class"""

        # Initialize members of the class
        if cost_basis is not APIHelper.SKIP:
            self.cost_basis = cost_basis 
        if current_value is not APIHelper.SKIP:
            self.current_value = current_value 
        if original_purchase_date is not APIHelper.SKIP:
            self.original_purchase_date = APIHelper.apply_datetime_converter(original_purchase_date, APIHelper.RFC3339DateTime) if original_purchase_date else None 
        if position_type is not APIHelper.SKIP:
            self.position_type = position_type 
        if purchased_price is not APIHelper.SKIP:
            self.purchased_price = purchased_price 
        if quantity is not APIHelper.SKIP:
            self.quantity = quantity 

        # Add additional model properties to the instance
        if additional_properties is None:
            additional_properties = {}
        self.additional_properties = additional_properties

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        cost_basis = dictionary.get("costBasis") if dictionary.get("costBasis") else APIHelper.SKIP
        current_value = dictionary.get("currentValue") if dictionary.get("currentValue") else APIHelper.SKIP
        original_purchase_date = APIHelper.RFC3339DateTime.from_value(dictionary.get("originalPurchaseDate")).datetime if dictionary.get("originalPurchaseDate") else APIHelper.SKIP
        position_type = dictionary.get("positionType") if dictionary.get("positionType") else APIHelper.SKIP
        purchased_price = dictionary.get("purchasedPrice") if dictionary.get("purchasedPrice") else APIHelper.SKIP
        quantity = dictionary.get("quantity") if dictionary.get("quantity") else APIHelper.SKIP
        additional_properties = APIHelper.get_additional_properties(
            dictionary={k: v for k, v in dictionary.items() if k not in cls._names.values()},
            unboxing_function=lambda value: value)
        # Return an object of this model
        return cls(cost_basis,
                   current_value,
                   original_purchase_date,
                   position_type,
                   purchased_price,
                   quantity,
                   additional_properties)

    @classmethod
    def validate(cls, dictionary):
        """Validates dictionary against class required properties

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            boolean : if dictionary is valid contains required properties.

        """

        if isinstance(dictionary, cls):
            return True

        if not isinstance(dictionary, dict):
            return False

        return True

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'cost_basis={(self.cost_basis if hasattr(self, "cost_basis") else None)!r}, '
                f'current_value={(self.current_value if hasattr(self, "current_value") else None)!r}, '
                f'original_purchase_date={(self.original_purchase_date if hasattr(self, "original_purchase_date") else None)!r}, '
                f'position_type={(self.position_type if hasattr(self, "position_type") else None)!r}, '
                f'purchased_price={(self.purchased_price if hasattr(self, "purchased_price") else None)!r}, '
                f'quantity={(self.quantity if hasattr(self, "quantity") else None)!r}, '
                f'additional_properties={self.additional_properties!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'cost_basis={(self.cost_basis if hasattr(self, "cost_basis") else None)!s}, '
                f'current_value={(self.current_value if hasattr(self, "current_value") else None)!s}, '
                f'original_purchase_date={(self.original_purchase_date if hasattr(self, "original_purchase_date") else None)!s}, '
                f'position_type={(self.position_type if hasattr(self, "position_type") else None)!s}, '
                f'purchased_price={(self.purchased_price if hasattr(self, "purchased_price") else None)!s}, '
                f'quantity={(self.quantity if hasattr(self, "quantity") else None)!s}, '
                f'additional_properties={self.additional_properties!s})')
